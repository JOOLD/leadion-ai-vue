import {
  Fragment,
  Teleport,
  Text,
  computed,
  createBlock,
  createElementBlock,
  createVNode,
  defineComponent,
  h,
  inject,
  mergeProps,
  onScopeDispose,
  openBlock,
  provide,
  ref,
  renderSlot,
  resolveDynamicComponent,
  shallowRef,
  toRef,
  triggerRef,
  useAttrs,
  useSlots,
  watch,
  watchEffect,
  withCtx
} from "./chunk-CYLFN3VO.js";
import "./chunk-G3PMV62Z.js";

// node_modules/@clerk/shared/dist/chunk-MDYQ4UNH.mjs
var DefaultMessages = Object.freeze({
  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,
  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`
});
function buildErrorThrower({ packageName, customMessages }) {
  let pkg = packageName;
  function buildMessage(rawMessage, replacements) {
    if (!replacements) {
      return `${pkg}: ${rawMessage}`;
    }
    let msg = rawMessage;
    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const match of matches) {
      const replacement = (replacements[match[1]] || "").toString();
      msg = msg.replace(`{{${match[1]}}}`, replacement);
    }
    return `${pkg}: ${msg}`;
  }
  const messages = {
    ...DefaultMessages,
    ...customMessages
  };
  return {
    setPackageName({ packageName: packageName2 }) {
      if (typeof packageName2 === "string") {
        pkg = packageName2;
      }
      return this;
    },
    setMessages({ customMessages: customMessages2 }) {
      Object.assign(messages, customMessages2 || {});
      return this;
    },
    throwInvalidPublishableKeyError(params) {
      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));
    },
    throwInvalidProxyUrl(params) {
      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));
    },
    throwMissingPublishableKeyError() {
      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(params) {
      throw new Error(buildMessage(messages.MissingClerkProvider, params));
    },
    throw(message) {
      throw new Error(buildMessage(message));
    }
  };
}

// node_modules/@clerk/shared/dist/chunk-7ELT755Q.mjs
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@clerk/vue/dist/chunk-ATMDUXZB.js
var errorThrower = buildErrorThrower({ packageName: "@clerk/vue" });
function setErrorThrowerOptions(options) {
  errorThrower.setMessages(options).setPackageName(options);
}

// node_modules/@clerk/shared/dist/chunk-3D4R2JFA.mjs
var versionSelector = (clerkJSVersion, packageVersion = "5.72.0") => {
  if (clerkJSVersion) {
    return clerkJSVersion;
  }
  const prereleaseTag = getPrereleaseTag(packageVersion);
  if (prereleaseTag) {
    if (prereleaseTag === "snapshot") {
      return "5.72.0";
    }
    return prereleaseTag;
  }
  return getMajorVersion(packageVersion);
};
var getPrereleaseTag = (packageVersion) => {
  var _a;
  return (_a = packageVersion.trim().replace(/^v/, "").match(/-(.+?)(\.|$)/)) == null ? void 0 : _a[1];
};
var getMajorVersion = (packageVersion) => packageVersion.trim().replace(/^v/, "").split(".")[0];

// node_modules/@clerk/shared/dist/chunk-6NDGN2IU.mjs
function isValidProxyUrl(key) {
  if (!key) {
    return true;
  }
  return isHttpOrHttps(key) || isProxyUrlRelative(key);
}
function isHttpOrHttps(key) {
  return /^http(s)?:\/\//.test(key || "");
}
function isProxyUrlRelative(key) {
  return key.startsWith("/");
}
function proxyUrlToAbsoluteURL(url) {
  if (!url) {
    return "";
  }
  return isProxyUrlRelative(url) ? new URL(url, window.location.origin).toString() : url;
}

// node_modules/@clerk/shared/dist/chunk-I6MTSTOF.mjs
var DEV_OR_STAGING_SUFFIXES = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
];

// node_modules/@clerk/shared/dist/chunk-IFTVZ2LQ.mjs
function addClerkPrefix(str) {
  if (!str) {
    return "";
  }
  let regex;
  if (str.match(/^(clerk\.)+\w*$/)) {
    regex = /(clerk\.)*(?=clerk\.)/;
  } else if (str.match(/\.clerk.accounts/)) {
    return str;
  } else {
    regex = /^(clerk\.)*/gi;
  }
  const stripped = str.replace(regex, "");
  return `clerk.${stripped}`;
}

// node_modules/@clerk/shared/dist/chunk-N2V3PKFE.mjs
var defaultOptions = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (_, iteration) => iteration < 5,
  retryImmediately: false,
  jitter: true
};
var RETRY_IMMEDIATELY_DELAY = 100;
var sleep = async (ms) => new Promise((s) => setTimeout(s, ms));
var applyJitter = (delay, jitter) => {
  return jitter ? delay * (1 + Math.random()) : delay;
};
var createExponentialDelayAsyncFn = (opts) => {
  let timesCalled = 0;
  const calculateDelayInMs = () => {
    const constant = opts.initialDelay;
    const base = opts.factor;
    let delay = constant * Math.pow(base, timesCalled);
    delay = applyJitter(delay, opts.jitter);
    return Math.min(opts.maxDelayBetweenRetries || delay, delay);
  };
  return async () => {
    await sleep(calculateDelayInMs());
    timesCalled++;
  };
};
var retry = async (callback, options = {}) => {
  let iterations = 0;
  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter } = {
    ...defaultOptions,
    ...options
  };
  const delay = createExponentialDelayAsyncFn({
    initialDelay,
    maxDelayBetweenRetries,
    factor,
    jitter
  });
  while (true) {
    try {
      return await callback();
    } catch (e) {
      iterations++;
      if (!shouldRetry(e, iterations)) {
        throw e;
      }
      if (retryImmediately && iterations === 1) {
        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));
      } else {
        await delay();
      }
    }
  }
};

// node_modules/@clerk/shared/dist/chunk-E3R3SJ7O.mjs
var NO_DOCUMENT_ERROR = "loadScript cannot be called when document does not exist";
var NO_SRC_ERROR = "loadScript cannot be called without a src";
async function loadScript(src = "", opts) {
  const { async, defer, beforeLoad, crossOrigin, nonce } = opts || {};
  const load = () => {
    return new Promise((resolve, reject) => {
      if (!src) {
        reject(new Error(NO_SRC_ERROR));
      }
      if (!document || !document.body) {
        reject(NO_DOCUMENT_ERROR);
      }
      const script = document.createElement("script");
      if (crossOrigin) script.setAttribute("crossorigin", crossOrigin);
      script.async = async || false;
      script.defer = defer || false;
      script.addEventListener("load", () => {
        script.remove();
        resolve(script);
      });
      script.addEventListener("error", () => {
        script.remove();
        reject();
      });
      script.src = src;
      script.nonce = nonce;
      beforeLoad == null ? void 0 : beforeLoad(script);
      document.body.appendChild(script);
    });
  };
  return retry(load, { shouldRetry: (_, iterations) => iterations <= 5 });
}

// node_modules/@clerk/shared/dist/chunk-TETGTEI2.mjs
var isomorphicAtob = (data) => {
  if (typeof atob !== "undefined" && typeof atob === "function") {
    return atob(data);
  } else if (typeof global !== "undefined" && global.Buffer) {
    return new global.Buffer(data, "base64").toString();
  }
  return data;
};

// node_modules/@clerk/shared/dist/chunk-IV7BOO4U.mjs
var PUBLISHABLE_KEY_LIVE_PREFIX = "pk_live_";
var PUBLISHABLE_KEY_TEST_PREFIX = "pk_test_";
function isValidDecodedPublishableKey(decoded) {
  if (!decoded.endsWith("$")) {
    return false;
  }
  const withoutTrailing = decoded.slice(0, -1);
  if (withoutTrailing.includes("$")) {
    return false;
  }
  return withoutTrailing.includes(".");
}
function parsePublishableKey(key, options = {}) {
  key = key || "";
  if (!key || !isPublishableKey(key)) {
    if (options.fatal && !key) {
      throw new Error(
        "Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys"
      );
    }
    if (options.fatal && !isPublishableKey(key)) {
      throw new Error("Publishable key not valid.");
    }
    return null;
  }
  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? "production" : "development";
  let decodedFrontendApi;
  try {
    decodedFrontendApi = isomorphicAtob(key.split("_")[2]);
  } catch {
    if (options.fatal) {
      throw new Error("Publishable key not valid: Failed to decode key.");
    }
    return null;
  }
  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {
    if (options.fatal) {
      throw new Error("Publishable key not valid: Decoded key has invalid format.");
    }
    return null;
  }
  let frontendApi = decodedFrontendApi.slice(0, -1);
  if (options.proxyUrl) {
    frontendApi = options.proxyUrl;
  } else if (instanceType !== "development" && options.domain && options.isSatellite) {
    frontendApi = `clerk.${options.domain}`;
  }
  return {
    instanceType,
    frontendApi
  };
}
function isPublishableKey(key = "") {
  try {
    const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);
    if (!hasValidPrefix) {
      return false;
    }
    const parts = key.split("_");
    if (parts.length !== 3) {
      return false;
    }
    const encodedPart = parts[2];
    if (!encodedPart) {
      return false;
    }
    const decoded = isomorphicAtob(encodedPart);
    return isValidDecodedPublishableKey(decoded);
  } catch {
    return false;
  }
}
function createDevOrStagingUrlCache() {
  const devOrStagingUrlCache = /* @__PURE__ */ new Map();
  return {
    /**
     * Checks if a URL is a development or staging environment.
     *
     * @param url - The URL to check (string or URL object).
     * @returns `true` if the URL is a development or staging environment, `false` otherwise.
     */
    isDevOrStagingUrl: (url) => {
      if (!url) {
        return false;
      }
      const hostname = typeof url === "string" ? url : url.hostname;
      let res = devOrStagingUrlCache.get(hostname);
      if (res === void 0) {
        res = DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));
        devOrStagingUrlCache.set(hostname, res);
      }
      return res;
    }
  };
}

// node_modules/@clerk/shared/dist/chunk-DP6IV622.mjs
var FAILED_TO_LOAD_ERROR = "Clerk: Failed to load Clerk";
var { isDevOrStagingUrl } = createDevOrStagingUrlCache();
var errorThrower2 = buildErrorThrower({ packageName: "@clerk/shared" });
function setClerkJsLoadingErrorPackageName(packageName) {
  errorThrower2.setPackageName({ packageName });
}
var loadClerkJsScript = async (opts) => {
  const existingScript = document.querySelector("script[data-clerk-js-script]");
  if (existingScript) {
    return new Promise((resolve, reject) => {
      existingScript.addEventListener("load", () => {
        resolve(existingScript);
      });
      existingScript.addEventListener("error", () => {
        reject(FAILED_TO_LOAD_ERROR);
      });
    });
  }
  if (!(opts == null ? void 0 : opts.publishableKey)) {
    errorThrower2.throwMissingPublishableKeyError();
    return;
  }
  return loadScript(clerkJsScriptUrl(opts), {
    async: true,
    crossOrigin: "anonymous",
    nonce: opts.nonce,
    beforeLoad: applyClerkJsScriptAttributes(opts)
  }).catch(() => {
    throw new Error(FAILED_TO_LOAD_ERROR);
  });
};
var clerkJsScriptUrl = (opts) => {
  var _a, _b;
  const { clerkJSUrl, clerkJSVariant, clerkJSVersion, proxyUrl, domain, publishableKey } = opts;
  if (clerkJSUrl) {
    return clerkJSUrl;
  }
  let scriptHost = "";
  if (!!proxyUrl && isValidProxyUrl(proxyUrl)) {
    scriptHost = proxyUrlToAbsoluteURL(proxyUrl).replace(/http(s)?:\/\//, "");
  } else if (domain && !isDevOrStagingUrl(((_a = parsePublishableKey(publishableKey)) == null ? void 0 : _a.frontendApi) || "")) {
    scriptHost = addClerkPrefix(domain);
  } else {
    scriptHost = ((_b = parsePublishableKey(publishableKey)) == null ? void 0 : _b.frontendApi) || "";
  }
  const variant = clerkJSVariant ? `${clerkJSVariant.replace(/\.+$/, "")}.` : "";
  const version = versionSelector(clerkJSVersion);
  return `https://${scriptHost}/npm/@clerk/clerk-js@${version}/dist/clerk.${variant}browser.js`;
};
var buildClerkJsScriptAttributes = (options) => {
  const obj = {};
  if (options.publishableKey) {
    obj["data-clerk-publishable-key"] = options.publishableKey;
  }
  if (options.proxyUrl) {
    obj["data-clerk-proxy-url"] = options.proxyUrl;
  }
  if (options.domain) {
    obj["data-clerk-domain"] = options.domain;
  }
  if (options.nonce) {
    obj.nonce = options.nonce;
  }
  return obj;
};
var applyClerkJsScriptAttributes = (options) => (script) => {
  const attributes = buildClerkJsScriptAttributes(options);
  for (const attribute in attributes) {
    script.setAttribute(attribute, attributes[attribute]);
  }
};

// node_modules/@clerk/shared/dist/chunk-7HPDNZ3R.mjs
var isDevelopmentEnvironment = () => {
  try {
    return true;
  } catch {
  }
  return false;
};
var isTestEnvironment = () => {
  try {
    return false;
  } catch {
  }
  return false;
};
var isProductionEnvironment = () => {
  try {
    return false;
  } catch {
  }
  return false;
};

// node_modules/@clerk/shared/dist/chunk-UEY4AZIP.mjs
var displayedWarnings = /* @__PURE__ */ new Set();
var deprecated = (fnName, warning, key) => {
  const hideWarning = isTestEnvironment() || isProductionEnvironment();
  const messageId = key ?? fnName;
  if (displayedWarnings.has(messageId) || hideWarning) {
    return;
  }
  displayedWarnings.add(messageId);
  console.warn(
    `Clerk - DEPRECATION WARNING: "${fnName}" is deprecated and will be removed in the next major release.
${warning}`
  );
};

// node_modules/@clerk/shared/dist/chunk-3CN5LOSN.mjs
var TYPES_TO_OBJECTS = {
  strict_mfa: {
    afterMinutes: 10,
    level: "multi_factor"
  },
  strict: {
    afterMinutes: 10,
    level: "second_factor"
  },
  moderate: {
    afterMinutes: 60,
    level: "second_factor"
  },
  lax: {
    afterMinutes: 1440,
    level: "second_factor"
  }
};
var ALLOWED_LEVELS = /* @__PURE__ */ new Set(["first_factor", "second_factor", "multi_factor"]);
var ALLOWED_TYPES = /* @__PURE__ */ new Set(["strict_mfa", "strict", "moderate", "lax"]);
var isValidMaxAge = (maxAge) => typeof maxAge === "number" && maxAge > 0;
var isValidLevel = (level) => ALLOWED_LEVELS.has(level);
var isValidVerificationType = (type) => ALLOWED_TYPES.has(type);
var prefixWithOrg = (value) => value.replace(/^(org:)*/, "org:");
var checkOrgAuthorization = (params, options) => {
  const { orgId, orgRole, orgPermissions } = options;
  if (!params.role && !params.permission) {
    return null;
  }
  if (!orgId || !orgRole || !orgPermissions) {
    return null;
  }
  if (params.permission) {
    return orgPermissions.includes(prefixWithOrg(params.permission));
  }
  if (params.role) {
    return prefixWithOrg(orgRole) === prefixWithOrg(params.role);
  }
  return null;
};
var checkForFeatureOrPlan = (claim, featureOrPlan) => {
  const { org: orgFeatures, user: userFeatures } = splitByScope(claim);
  const [scope, _id] = featureOrPlan.split(":");
  const id = _id || scope;
  if (scope === "org") {
    return orgFeatures.includes(id);
  } else if (scope === "user") {
    return userFeatures.includes(id);
  } else {
    return [...orgFeatures, ...userFeatures].includes(id);
  }
};
var checkBillingAuthorization = (params, options) => {
  const { features, plans } = options;
  if (params.feature && features) {
    return checkForFeatureOrPlan(features, params.feature);
  }
  if (params.plan && plans) {
    return checkForFeatureOrPlan(plans, params.plan);
  }
  return null;
};
var splitByScope = (fea) => {
  const features = fea ? fea.split(",").map((f) => f.trim()) : [];
  return {
    org: features.filter((f) => f.split(":")[0].includes("o")).map((f) => f.split(":")[1]),
    user: features.filter((f) => f.split(":")[0].includes("u")).map((f) => f.split(":")[1])
  };
};
var validateReverificationConfig = (config) => {
  if (!config) {
    return false;
  }
  const convertConfigToObject = (config2) => {
    if (typeof config2 === "string") {
      return TYPES_TO_OBJECTS[config2];
    }
    return config2;
  };
  const isValidStringValue = typeof config === "string" && isValidVerificationType(config);
  const isValidObjectValue = typeof config === "object" && isValidLevel(config.level) && isValidMaxAge(config.afterMinutes);
  if (isValidStringValue || isValidObjectValue) {
    return convertConfigToObject.bind(null, config);
  }
  return false;
};
var checkReverificationAuthorization = (params, { factorVerificationAge }) => {
  if (!params.reverification || !factorVerificationAge) {
    return null;
  }
  const isValidReverification = validateReverificationConfig(params.reverification);
  if (!isValidReverification) {
    return null;
  }
  const { level, afterMinutes } = isValidReverification();
  const [factor1Age, factor2Age] = factorVerificationAge;
  const isValidFactor1 = factor1Age !== -1 ? afterMinutes > factor1Age : null;
  const isValidFactor2 = factor2Age !== -1 ? afterMinutes > factor2Age : null;
  switch (level) {
    case "first_factor":
      return isValidFactor1;
    case "second_factor":
      return factor2Age !== -1 ? isValidFactor2 : isValidFactor1;
    case "multi_factor":
      return factor2Age === -1 ? isValidFactor1 : isValidFactor1 && isValidFactor2;
  }
};
var createCheckAuthorization = (options) => {
  return (params) => {
    if (!options.userId) {
      return false;
    }
    const billingAuthorization = checkBillingAuthorization(params, options);
    const orgAuthorization = checkOrgAuthorization(params, options);
    const reverificationAuthorization = checkReverificationAuthorization(params, options);
    if ([billingAuthorization || orgAuthorization, reverificationAuthorization].some((a) => a === null)) {
      return [billingAuthorization || orgAuthorization, reverificationAuthorization].some((a) => a === true);
    }
    return [billingAuthorization || orgAuthorization, reverificationAuthorization].every((a) => a === true);
  };
};
var resolveAuthState = ({
  authObject: {
    sessionId,
    sessionStatus,
    userId,
    actor,
    orgId,
    orgRole,
    orgSlug,
    signOut,
    getToken,
    has,
    sessionClaims
  },
  options: { treatPendingAsSignedOut = true }
}) => {
  if (sessionId === void 0 && userId === void 0) {
    return {
      isLoaded: false,
      isSignedIn: void 0,
      sessionId,
      sessionClaims: void 0,
      userId,
      actor: void 0,
      orgId: void 0,
      orgRole: void 0,
      orgSlug: void 0,
      has: void 0,
      signOut,
      getToken
    };
  }
  if (sessionId === null && userId === null) {
    return {
      isLoaded: true,
      isSignedIn: false,
      sessionId,
      userId,
      sessionClaims: null,
      actor: null,
      orgId: null,
      orgRole: null,
      orgSlug: null,
      has: () => false,
      signOut,
      getToken
    };
  }
  if (treatPendingAsSignedOut && sessionStatus === "pending") {
    return {
      isLoaded: true,
      isSignedIn: false,
      sessionId: null,
      userId: null,
      sessionClaims: null,
      actor: null,
      orgId: null,
      orgRole: null,
      orgSlug: null,
      has: () => false,
      signOut,
      getToken
    };
  }
  if (!!sessionId && !!sessionClaims && !!userId && !!orgId && !!orgRole) {
    return {
      isLoaded: true,
      isSignedIn: true,
      sessionId,
      sessionClaims,
      userId,
      actor: actor || null,
      orgId,
      orgRole,
      orgSlug: orgSlug || null,
      has,
      signOut,
      getToken
    };
  }
  if (!!sessionId && !!sessionClaims && !!userId && !orgId) {
    return {
      isLoaded: true,
      isSignedIn: true,
      sessionId,
      sessionClaims,
      userId,
      actor: actor || null,
      orgId: null,
      orgRole: null,
      orgSlug: null,
      has,
      signOut,
      getToken
    };
  }
};

// node_modules/@clerk/shared/dist/chunk-GGFRMWFO.mjs
function snakeToCamel(str) {
  return str ? str.replace(/([-_][a-z])/g, (match) => match.toUpperCase().replace(/-|_/, "")) : "";
}
function camelToSnake(str) {
  return str ? str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`) : "";
}
var createDeepObjectTransformer = (transform) => {
  const deepTransform = (obj) => {
    if (!obj) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((el) => {
        if (typeof el === "object" || Array.isArray(el)) {
          return deepTransform(el);
        }
        return el;
      });
    }
    const copy = { ...obj };
    const keys = Object.keys(copy);
    for (const oldName of keys) {
      const newName = transform(oldName.toString());
      if (newName !== oldName) {
        copy[newName] = copy[oldName];
        delete copy[oldName];
      }
      if (typeof copy[newName] === "object") {
        copy[newName] = deepTransform(copy[newName]);
      }
    }
    return copy;
  };
  return deepTransform;
};
var deepCamelToSnake = createDeepObjectTransformer(camelToSnake);
var deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);

// node_modules/@clerk/shared/dist/chunk-YXR7ZZRP.mjs
var _storageKey;
var _cacheTtl;
var _TelemetryEventThrottler_instances;
var generateKey_fn;
var cache_get;
var isValidBrowser_get;
_storageKey = /* @__PURE__ */ new WeakMap();
_cacheTtl = /* @__PURE__ */ new WeakMap();
_TelemetryEventThrottler_instances = /* @__PURE__ */ new WeakSet();
generateKey_fn = function(event) {
  const { sk: _sk, pk: _pk, payload, ...rest } = event;
  const sanitizedEvent = {
    ...payload,
    ...rest
  };
  return JSON.stringify(
    Object.keys({
      ...payload,
      ...rest
    }).sort().map((key) => sanitizedEvent[key])
  );
};
cache_get = function() {
  const cacheString = localStorage.getItem(__privateGet(this, _storageKey));
  if (!cacheString) {
    return {};
  }
  return JSON.parse(cacheString);
};
isValidBrowser_get = function() {
  if (typeof window === "undefined") {
    return false;
  }
  const storage = window.localStorage;
  if (!storage) {
    return false;
  }
  try {
    const testKey = "test";
    storage.setItem(testKey, testKey);
    storage.removeItem(testKey);
    return true;
  } catch (err) {
    const isQuotaExceededError = err instanceof DOMException && // Check error names for different browsers
    (err.name === "QuotaExceededError" || err.name === "NS_ERROR_DOM_QUOTA_REACHED");
    if (isQuotaExceededError && storage.length > 0) {
      storage.removeItem(__privateGet(this, _storageKey));
    }
    return false;
  }
};
var _config;
var _eventThrottler;
var _metadata;
var _buffer;
var _pendingFlush;
var _TelemetryCollector_instances;
var shouldRecord_fn;
var shouldBeSampled_fn;
var scheduleFlush_fn;
var flush_fn;
var logEvent_fn;
var getSDKMetadata_fn;
var preparePayload_fn;
_config = /* @__PURE__ */ new WeakMap();
_eventThrottler = /* @__PURE__ */ new WeakMap();
_metadata = /* @__PURE__ */ new WeakMap();
_buffer = /* @__PURE__ */ new WeakMap();
_pendingFlush = /* @__PURE__ */ new WeakMap();
_TelemetryCollector_instances = /* @__PURE__ */ new WeakSet();
shouldRecord_fn = function(preparedPayload, eventSamplingRate) {
  return this.isEnabled && !this.isDebug && __privateMethod(this, _TelemetryCollector_instances, shouldBeSampled_fn).call(this, preparedPayload, eventSamplingRate);
};
shouldBeSampled_fn = function(preparedPayload, eventSamplingRate) {
  const randomSeed = Math.random();
  const toBeSampled = randomSeed <= __privateGet(this, _config).samplingRate && (typeof eventSamplingRate === "undefined" || randomSeed <= eventSamplingRate);
  if (!toBeSampled) {
    return false;
  }
  return !__privateGet(this, _eventThrottler).isEventThrottled(preparedPayload);
};
scheduleFlush_fn = function() {
  if (typeof window === "undefined") {
    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    return;
  }
  const isBufferFull = __privateGet(this, _buffer).length >= __privateGet(this, _config).maxBufferSize;
  if (isBufferFull) {
    if (__privateGet(this, _pendingFlush)) {
      const cancel = typeof cancelIdleCallback !== "undefined" ? cancelIdleCallback : clearTimeout;
      cancel(__privateGet(this, _pendingFlush));
    }
    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    return;
  }
  if (__privateGet(this, _pendingFlush)) {
    return;
  }
  if ("requestIdleCallback" in window) {
    __privateSet(this, _pendingFlush, requestIdleCallback(() => {
      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    }));
  } else {
    __privateSet(this, _pendingFlush, setTimeout(() => {
      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);
    }, 0));
  }
};
flush_fn = function() {
  fetch(new URL("/v1/event", __privateGet(this, _config).endpoint), {
    method: "POST",
    // TODO: We send an array here with that idea that we can eventually send multiple events.
    body: JSON.stringify({
      events: __privateGet(this, _buffer)
    }),
    headers: {
      "Content-Type": "application/json"
    }
  }).catch(() => void 0).then(() => {
    __privateSet(this, _buffer, []);
  }).catch(() => void 0);
};
logEvent_fn = function(event, payload) {
  if (!this.isDebug) {
    return;
  }
  if (typeof console.groupCollapsed !== "undefined") {
    console.groupCollapsed("[clerk/telemetry]", event);
    console.log(payload);
    console.groupEnd();
  } else {
    console.log("[clerk/telemetry]", event, payload);
  }
};
getSDKMetadata_fn = function() {
  let sdkMetadata = {
    name: __privateGet(this, _metadata).sdk,
    version: __privateGet(this, _metadata).sdkVersion
  };
  if (typeof window !== "undefined" && window.Clerk) {
    sdkMetadata = { ...sdkMetadata, ...window.Clerk.constructor.sdkMetadata };
  }
  return sdkMetadata;
};
preparePayload_fn = function(event, payload) {
  const sdkMetadata = __privateMethod(this, _TelemetryCollector_instances, getSDKMetadata_fn).call(this);
  return {
    event,
    cv: __privateGet(this, _metadata).clerkVersion ?? "",
    it: __privateGet(this, _metadata).instanceType ?? "",
    sdk: sdkMetadata.name,
    sdkv: sdkMetadata.version,
    ...__privateGet(this, _metadata).publishableKey ? { pk: __privateGet(this, _metadata).publishableKey } : {},
    ...__privateGet(this, _metadata).secretKey ? { sk: __privateGet(this, _metadata).secretKey } : {},
    payload
  };
};
var EVENT_METHOD_CALLED = "METHOD_CALLED";
function eventMethodCalled(method, payload) {
  return {
    event: EVENT_METHOD_CALLED,
    payload: {
      method,
      ...payload
    }
  };
}

// node_modules/@clerk/shared/dist/chunk-IBXKDGSZ.mjs
function getCurrentOrganizationMembership(organizationMemberships, organizationId) {
  return organizationMemberships.find(
    (organizationMembership) => organizationMembership.organization.id === organizationId
  );
}

// node_modules/@clerk/shared/dist/chunk-ARQUL5DC.mjs
var logErrorInDevMode = (message) => {
  if (isDevelopmentEnvironment()) {
    console.error(`Clerk: ${message}`);
  }
};

// node_modules/@clerk/shared/dist/chunk-JKSAJ6AV.mjs
function inBrowser() {
  return typeof window !== "undefined";
}
var botAgents = [
  "bot",
  "spider",
  "crawl",
  "APIs-Google",
  "AdsBot",
  "Googlebot",
  "mediapartners",
  "Google Favicon",
  "FeedFetcher",
  "Google-Read-Aloud",
  "DuplexWeb-Google",
  "googleweblight",
  "bing",
  "yandex",
  "baidu",
  "duckduck",
  "yahoo",
  "ecosia",
  "ia_archiver",
  "facebook",
  "instagram",
  "pinterest",
  "reddit",
  "slack",
  "twitter",
  "whatsapp",
  "youtube",
  "semrush"
];
var botAgentRegex = new RegExp(botAgents.join("|"), "i");

// node_modules/@clerk/shared/dist/chunk-ZIXJBK4O.mjs
var deriveState = (clerkOperational, state, initialState) => {
  if (!clerkOperational && initialState) {
    return deriveFromSsrInitialState(initialState);
  }
  return deriveFromClientSideState(state);
};
var deriveFromSsrInitialState = (initialState) => {
  const userId = initialState.userId;
  const user = initialState.user;
  const sessionId = initialState.sessionId;
  const sessionStatus = initialState.sessionStatus;
  const sessionClaims = initialState.sessionClaims;
  const session = initialState.session;
  const organization = initialState.organization;
  const orgId = initialState.orgId;
  const orgRole = initialState.orgRole;
  const orgPermissions = initialState.orgPermissions;
  const orgSlug = initialState.orgSlug;
  const actor = initialState.actor;
  const factorVerificationAge = initialState.factorVerificationAge;
  return {
    userId,
    user,
    sessionId,
    session,
    sessionStatus,
    sessionClaims,
    organization,
    orgId,
    orgRole,
    orgPermissions,
    orgSlug,
    actor,
    factorVerificationAge
  };
};
var deriveFromClientSideState = (state) => {
  var _a, _b, _c, _d;
  const userId = state.user ? state.user.id : state.user;
  const user = state.user;
  const sessionId = state.session ? state.session.id : state.session;
  const session = state.session;
  const sessionStatus = (_a = state.session) == null ? void 0 : _a.status;
  const sessionClaims = state.session ? (_c = (_b = state.session.lastActiveToken) == null ? void 0 : _b.jwt) == null ? void 0 : _c.claims : null;
  const factorVerificationAge = state.session ? state.session.factorVerificationAge : null;
  const actor = session == null ? void 0 : session.actor;
  const organization = state.organization;
  const orgId = state.organization ? state.organization.id : state.organization;
  const orgSlug = organization == null ? void 0 : organization.slug;
  const membership = organization ? (_d = user == null ? void 0 : user.organizationMemberships) == null ? void 0 : _d.find((om) => om.organization.id === orgId) : organization;
  const orgPermissions = membership ? membership.permissions : membership;
  const orgRole = membership ? membership.role : membership;
  return {
    userId,
    user,
    sessionId,
    session,
    sessionStatus,
    sessionClaims,
    organization,
    orgId,
    orgRole,
    orgSlug,
    orgPermissions,
    actor,
    factorVerificationAge
  };
};

// node_modules/@clerk/vue/dist/index.js
var multipleChildrenInButtonComponent = (name) => `You've passed multiple children components to <${name}/>. You can only pass a single child component or text.`;
var invalidStateError = "Invalid state. Feel free to submit a bug or reach out to support here: https://clerk.com/support";
var userButtonMenuActionRenderedError = "<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`.";
var userButtonMenuLinkRenderedError = "<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`.";
var userButtonMenuItemLinkWrongProps = "Missing requirements. <UserButton.Link /> component requires props: href, label and slots: labelIcon.";
var userButtonMenuItemActionWrongProps = "Missing requirements. <UserButton.Action /> component requires props: label and slots: labelIcon.";
var userButtonMenuItemsRenderedError = "<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`.";
var customPageWrongProps = (componentName) => `Missing requirements. <${componentName}.Page /> component requires props: url, label and slots: labelIcon and a default slot for page content`;
var customLinkWrongProps = (componentName) => `Missing requirements. <${componentName}.Link /> component requires the following props: url, label and slots: labelIcon.`;
var userProfilePageRenderedError = "<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.";
var userProfileLinkRenderedError = "<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`.";
var organizationProfilePageRenderedError = "<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.";
var organizationProfileLinkRenderedError = "<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`.";
var normalizeWithDefaultValue = (slotContent, defaultValue) => {
  if (!slotContent) {
    return h("button", defaultValue);
  }
  if (slotContent[0].type === Text) {
    return h("button", slotContent);
  }
  return slotContent;
};
var assertSingleChild = (slotContent, name) => {
  if (Array.isArray(slotContent)) {
    if (slotContent.length > 1) {
      return errorThrower.throw(multipleChildrenInButtonComponent(name));
    }
    return slotContent[0];
  }
  return slotContent;
};
function toComputedRefs(objectRef) {
  const result = {};
  for (const key in objectRef.value) {
    result[key] = computed(() => objectRef.value[key]);
  }
  return result;
}
var ClerkInjectionKey = Symbol("clerk");
var UserButtonInjectionKey = Symbol("UserButton");
var UserButtonMenuItemsInjectionKey = Symbol("UserButton.MenuItems");
var UserProfileInjectionKey = Symbol("UserProfile");
var OrganizationProfileInjectionKey = Symbol("OrganizationProfile");
function useClerkContext() {
  const ctx = inject(ClerkInjectionKey);
  if (!ctx) {
    throw new Error(
      "This component/composable can only be used when the Vue plugin is installed. Learn more: https://clerk.com/docs/quickstarts/vue"
    );
  }
  return ctx;
}
var useUser = () => {
  const { userCtx } = useClerkContext();
  const result = computed(() => {
    if (userCtx.value === void 0) {
      return { isLoaded: false, isSignedIn: void 0, user: void 0 };
    }
    if (userCtx.value === null) {
      return { isLoaded: true, isSignedIn: false, user: null };
    }
    return { isLoaded: true, isSignedIn: true, user: userCtx.value };
  });
  return toComputedRefs(result);
};
var useSession = (options = {}) => {
  const { sessionCtx, ...clerkContext } = useClerkContext();
  const result = computed(() => {
    var _a;
    if (sessionCtx.value === void 0) {
      return { isLoaded: false, isSignedIn: void 0, session: void 0 };
    }
    const pendingAsSignedOut = ((_a = sessionCtx.value) == null ? void 0 : _a.status) === "pending" && (options.treatPendingAsSignedOut ?? clerkContext.treatPendingAsSignedOut);
    const isSignedOut = sessionCtx.value === null || pendingAsSignedOut;
    if (isSignedOut) {
      return { isLoaded: true, isSignedIn: false, session: null };
    }
    return { isLoaded: true, isSignedIn: true, session: sessionCtx.value };
  });
  return toComputedRefs(result);
};
var useClerk = () => {
  const { clerk } = useClerkContext();
  return clerk;
};
var useSignIn = () => {
  const { clerk, clientCtx } = useClerkContext();
  const unwatch = watch(clerk, (value) => {
    var _a;
    if (value) {
      (_a = value.telemetry) == null ? void 0 : _a.record(eventMethodCalled("useSignIn"));
      unwatch();
    }
  });
  const result = computed(() => {
    if (!clerk.value || !clientCtx.value) {
      return { isLoaded: false, signIn: void 0, setActive: void 0 };
    }
    return {
      isLoaded: true,
      signIn: clientCtx.value.signIn,
      setActive: clerk.value.setActive
    };
  });
  return toComputedRefs(result);
};
var useSignUp = () => {
  const { clerk, clientCtx } = useClerkContext();
  const unwatch = watch(clerk, (value) => {
    var _a;
    if (value) {
      (_a = value.telemetry) == null ? void 0 : _a.record(eventMethodCalled("useSignUp"));
      unwatch();
    }
  });
  const result = computed(() => {
    if (!clerk.value || !clientCtx.value) {
      return { isLoaded: false, signUp: void 0, setActive: void 0 };
    }
    return {
      isLoaded: true,
      signUp: clientCtx.value.signUp,
      setActive: clerk.value.setActive
    };
  });
  return toComputedRefs(result);
};
var useSessionList = () => {
  const { clerk, clientCtx } = useClerkContext();
  const result = computed(() => {
    if (!clientCtx.value) {
      return { isLoaded: false, sessions: void 0, setActive: void 0 };
    }
    return {
      isLoaded: true,
      sessions: clientCtx.value.sessions,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      setActive: clerk.value.setActive
    };
  });
  return toComputedRefs(result);
};
var useOrganization = () => {
  const { clerk, organizationCtx } = useClerkContext();
  const { session } = useSession();
  const result = computed(() => {
    var _a;
    if (organizationCtx.value === void 0) {
      return { isLoaded: false, organization: void 0, membership: void 0 };
    }
    if (organizationCtx.value === null) {
      return { isLoaded: true, organization: null, membership: null };
    }
    if (!((_a = clerk.value) == null ? void 0 : _a.loaded)) {
      return {
        isLoaded: true,
        organization: organizationCtx.value,
        membership: void 0
      };
    }
    return {
      isLoaded: clerk.value.loaded,
      organization: organizationCtx.value,
      membership: getCurrentOrganizationMembership(
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        session.value.user.organizationMemberships,
        organizationCtx.value.id
      )
    };
  });
  return toComputedRefs(result);
};
var useClerkLoaded = (callback) => {
  const clerk = useClerk();
  watch(
    clerk,
    (unwrappedClerk) => {
      if (!(unwrappedClerk == null ? void 0 : unwrappedClerk.loaded)) {
        return;
      }
      callback(unwrappedClerk);
    },
    { immediate: true }
  );
};
function updateClerkOptions(options) {
  if (!window.Clerk) {
    throw new Error("Missing Clerk instance");
  }
  void window.Clerk.__unstable__updateProps({
    options: {
      localization: options.localization
    },
    appearance: options.appearance
  });
}
function clerkLoaded(clerk) {
  return new Promise((resolve) => {
    watch(
      clerk,
      (value) => {
        if (value == null ? void 0 : value.loaded) {
          resolve(value);
        }
      },
      { immediate: true }
    );
  });
}
function createGetToken(clerk) {
  return async (options) => {
    const loadedClerk = await clerkLoaded(clerk);
    if (!loadedClerk.session) {
      return null;
    }
    return loadedClerk.session.getToken(options);
  };
}
function createSignOut(clerk) {
  return async (...args) => {
    const loadedClerk = await clerkLoaded(clerk);
    return loadedClerk.signOut(...args);
  };
}
var useAuth = (options = {}) => {
  const { clerk, authCtx, ...contextOptions } = useClerkContext();
  const getToken = createGetToken(clerk);
  const signOut = createSignOut(clerk);
  const result = computed(() => {
    const { userId, orgId, orgRole, orgPermissions, sessionClaims, factorVerificationAge } = authCtx.value;
    const has = createCheckAuthorization({
      userId,
      orgId,
      orgRole,
      orgPermissions,
      factorVerificationAge,
      features: (sessionClaims == null ? void 0 : sessionClaims.fea) || "",
      plans: (sessionClaims == null ? void 0 : sessionClaims.pla) || ""
    });
    const payload = resolveAuthState({
      authObject: {
        ...authCtx.value,
        getToken,
        signOut,
        has
      },
      options: {
        treatPendingAsSignedOut: options.treatPendingAsSignedOut ?? contextOptions.treatPendingAsSignedOut
      }
    });
    if (!payload) {
      return errorThrower.throw(invalidStateError);
    }
    return payload;
  });
  return toComputedRefs(result);
};
var SignedIn = defineComponent(({ treatPendingAsSignedOut }, { slots }) => {
  const { userId } = useAuth({ treatPendingAsSignedOut });
  return () => {
    var _a;
    return userId.value ? (_a = slots.default) == null ? void 0 : _a.call(slots) : null;
  };
});
Object.defineProperty(SignedIn, "props", {
  value: ["treatPendingAsSignedOut"]
});
var SignedOut = defineComponent(({ treatPendingAsSignedOut }, { slots }) => {
  const { userId } = useAuth({ treatPendingAsSignedOut });
  return () => {
    var _a;
    return userId.value === null ? (_a = slots.default) == null ? void 0 : _a.call(slots) : null;
  };
});
Object.defineProperty(SignedOut, "props", {
  value: ["treatPendingAsSignedOut"]
});
var ClerkLoaded = defineComponent((_, { slots }) => {
  const clerk = useClerk();
  return () => {
    var _a, _b;
    return ((_a = clerk.value) == null ? void 0 : _a.loaded) ? (_b = slots.default) == null ? void 0 : _b.call(slots) : null;
  };
});
var ClerkLoading = defineComponent((_, { slots }) => {
  const clerk = useClerk();
  return () => {
    var _a, _b;
    return !((_a = clerk.value) == null ? void 0 : _a.loaded) ? (_b = slots.default) == null ? void 0 : _b.call(slots) : null;
  };
});
var RedirectToSignIn = defineComponent((props) => {
  const { sessionCtx, clientCtx } = useClerkContext();
  useClerkLoaded((clerk) => {
    var _a;
    const hasSignedInSessions = ((_a = clientCtx.value) == null ? void 0 : _a.signedInSessions) && clientCtx.value.signedInSessions.length > 0;
    if (sessionCtx.value === null && hasSignedInSessions) {
      void clerk.redirectToAfterSignOut();
    } else {
      void clerk.redirectToSignIn(props);
    }
  });
  return () => null;
});
Object.defineProperty(RedirectToSignIn, "props", {
  value: ["signInForceRedirectUrl", "signInFallbackRedirectUrl", "signUpForceRedirectUrl", "signUpFallbackRedirectUrl", "afterSignInUrl", "afterSignUpUrl", "redirectUrl"]
});
var RedirectToSignUp = defineComponent((props) => {
  useClerkLoaded((clerk) => {
    void clerk.redirectToSignUp(props);
  });
  return () => null;
});
Object.defineProperty(RedirectToSignUp, "props", {
  value: ["signInForceRedirectUrl", "signInFallbackRedirectUrl", "signUpForceRedirectUrl", "signUpFallbackRedirectUrl", "afterSignInUrl", "afterSignUpUrl", "redirectUrl"]
});
var RedirectToUserProfile = defineComponent(() => {
  useClerkLoaded((clerk) => {
    deprecated("RedirectToUserProfile", "Use the `redirectToUserProfile()` method instead.");
    void clerk.redirectToUserProfile();
  });
  return () => null;
});
var RedirectToOrganizationProfile = defineComponent(() => {
  useClerkLoaded((clerk) => {
    deprecated("RedirectToOrganizationProfile", "Use the `redirectToOrganizationProfile()` method instead.");
    void clerk.redirectToOrganizationProfile();
  });
  return () => null;
});
var RedirectToCreateOrganization = defineComponent(() => {
  useClerkLoaded((clerk) => {
    deprecated("RedirectToCreateOrganization", "Use the `redirectToCreateOrganization()` method instead.");
    void clerk.redirectToCreateOrganization();
  });
  return () => null;
});
var AuthenticateWithRedirectCallback = defineComponent((props) => {
  useClerkLoaded((clerk) => {
    void clerk.handleRedirectCallback(props);
  });
  return () => null;
});
Object.defineProperty(AuthenticateWithRedirectCallback, "props", {
  value: ["transferable", "signInForceRedirectUrl", "signInFallbackRedirectUrl", "signUpForceRedirectUrl", "signUpFallbackRedirectUrl", "afterSignInUrl", "afterSignUpUrl", "redirectUrl", "signInUrl", "signUpUrl", "firstFactorUrl", "secondFactorUrl", "resetPasswordUrl", "continueSignUpUrl", "verifyEmailAddressUrl", "verifyPhoneNumberUrl", "reloadResource"]
});
var Protect = defineComponent((props, { slots }) => {
  const { isLoaded, has, userId } = useAuth({ treatPendingAsSignedOut: props.treatPendingAsSignedOut });
  return () => {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!isLoaded.value) {
      return null;
    }
    if (!userId.value) {
      return (_a = slots.fallback) == null ? void 0 : _a.call(slots);
    }
    if (typeof props.condition === "function") {
      if (props.condition(has.value)) {
        return (_b = slots.default) == null ? void 0 : _b.call(slots);
      }
      return (_c = slots.fallback) == null ? void 0 : _c.call(slots);
    }
    if (props.role || props.permission || props.feature || props.plan) {
      if ((_d = has.value) == null ? void 0 : _d.call(has, props)) {
        return (_e = slots.default) == null ? void 0 : _e.call(slots);
      }
      return (_f = slots.fallback) == null ? void 0 : _f.call(slots);
    }
    return (_g = slots.default) == null ? void 0 : _g.call(slots);
  };
});
Object.defineProperty(Protect, "props", {
  value: ["condition", "role", "permission", "feature", "plan", "treatPendingAsSignedOut"]
});
var CustomPortalsRenderer = defineComponent((props) => {
  return () => [...(props == null ? void 0 : props.customPagesPortals) ?? [], ...(props == null ? void 0 : props.customMenuItemsPortals) ?? []];
});
Object.defineProperty(CustomPortalsRenderer, "props", {
  value: ["customPagesPortals", "customMenuItemsPortals"]
});
var ClerkHostRenderer = defineComponent({
  props: {
    mount: {
      type: Function,
      required: false
    },
    unmount: {
      type: Function,
      required: false
    },
    open: {
      type: Function,
      required: false
    },
    close: {
      type: Function,
      required: false
    },
    updateProps: {
      type: Function,
      required: false
    },
    props: {
      type: Object,
      required: false,
      default: () => ({})
    }
  },
  setup(props) {
    const portalRef = ref(null);
    const isPortalMounted = ref(false);
    const componentProps = toRef(props, "props");
    watchEffect(() => {
      var _a;
      if (!portalRef.value) {
        return;
      }
      if (isPortalMounted.value) {
        (_a = props.updateProps) == null ? void 0 : _a.call(props, { node: portalRef.value, props: componentProps.value });
      } else {
        if (props.mount) {
          props.mount(portalRef.value, componentProps.value);
        }
        if (props.open) {
          props.open(componentProps.value);
        }
        isPortalMounted.value = true;
      }
    });
    onScopeDispose(() => {
      if (isPortalMounted.value && portalRef.value) {
        if (props.unmount) {
          props.unmount(portalRef.value);
        }
        if (props.close) {
          props.close();
        }
      }
    });
    return () => h(ClerkLoaded, () => h("div", { ref: portalRef }));
  }
});
var export_helper_default = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
var _sfc_main = defineComponent({
  __name: "SignIn",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    signInUrl: { type: String, required: false },
    signUpUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    initialValues: { type: Object, required: false },
    __experimental: { type: Object, required: false },
    waitlistUrl: { type: String, required: false },
    unsafeMetadata: { type: null, required: false },
    withSignUp: { type: Boolean, required: false },
    oauthFlow: { type: String, required: false },
    oidcPrompt: { type: String, required: false },
    transferable: { type: Boolean, required: false },
    signUpForceRedirectUrl: { type: [String, null], required: false },
    signUpFallbackRedirectUrl: { type: [String, null], required: false },
    afterSignInUrl: { type: [String, null], required: false },
    afterSignUpUrl: { type: [String, null], required: false },
    redirectUrl: { type: [String, null], required: false },
    afterSignOutUrl: { type: [String, null], required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: (_a = $setup.clerk) == null ? void 0 : _a.mountSignIn,
    unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountSignIn,
    props: $setup.props,
    "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps
  }, null, 8, ["mount", "unmount", "props", "update-props"]);
}
var SignIn_default = export_helper_default(_sfc_main, [["render", _sfc_render], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/SignIn.vue"]]);
var _sfc_main2 = defineComponent({
  __name: "SignUp",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    signInUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    unsafeMetadata: { type: null, required: false },
    initialValues: { type: Object, required: false },
    __experimental: { type: Object, required: false },
    waitlistUrl: { type: String, required: false },
    oauthFlow: { type: String, required: false },
    oidcPrompt: { type: String, required: false },
    signInFallbackRedirectUrl: { type: [String, null], required: false },
    signInForceRedirectUrl: { type: [String, null], required: false },
    afterSignInUrl: { type: [String, null], required: false },
    afterSignUpUrl: { type: [String, null], required: false },
    redirectUrl: { type: [String, null], required: false },
    afterSignOutUrl: { type: [String, null], required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: (_a = $setup.clerk) == null ? void 0 : _a.mountSignUp,
    unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountSignUp,
    props: $setup.props,
    "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps
  }, null, 8, ["mount", "unmount", "props", "update-props"]);
}
var SignUp_default = export_helper_default(_sfc_main2, [["render", _sfc_render2], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/SignUp.vue"]]);
var _sfc_main3 = defineComponent({
  __name: "GoogleOneTap",
  props: {
    signInForceRedirectUrl: { type: [String, null], required: false },
    signUpForceRedirectUrl: { type: [String, null], required: false },
    cancelOnTapOutside: { type: Boolean, required: false },
    itpSupport: { type: Boolean, required: false },
    fedCmSupport: { type: Boolean, required: false },
    appearance: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b;
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    open: (_a = $setup.clerk) == null ? void 0 : _a.openGoogleOneTap,
    close: (_b = $setup.clerk) == null ? void 0 : _b.closeGoogleOneTap,
    props: $setup.props
  }, null, 8, ["open", "close", "props"]);
}
var GoogleOneTap_default = export_helper_default(_sfc_main3, [["render", _sfc_render3], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/GoogleOneTap.vue"]]);
var _sfc_main4 = defineComponent({
  __name: "Waitlist",
  props: {
    afterJoinWaitlistUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    signInUrl: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: (_a = $setup.clerk) == null ? void 0 : _a.mountWaitlist,
    unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountWaitlist,
    "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var Waitlist_default = export_helper_default(_sfc_main4, [["render", _sfc_render4], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/Waitlist.vue"]]);
var _sfc_main5 = defineComponent({
  __name: "CreateOrganization",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    afterCreateOrganizationUrl: { type: Function, required: false, skipCheck: true },
    skipInvitationScreen: { type: Boolean, required: false },
    appearance: { type: Object, required: false },
    hideSlug: { type: Boolean, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: (_a = $setup.clerk) == null ? void 0 : _a.mountCreateOrganization,
    unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountCreateOrganization,
    "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var CreateOrganization_default = export_helper_default(_sfc_main5, [["render", _sfc_render5], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/CreateOrganization.vue"]]);
var _sfc_main6 = defineComponent({
  __name: "OrganizationList",
  props: {
    afterCreateOrganizationUrl: { type: Function, required: false, skipCheck: true },
    afterSelectOrganizationUrl: { type: Function, required: false, skipCheck: true },
    appearance: { type: Object, required: false },
    skipInvitationScreen: { type: Boolean, required: false },
    hidePersonal: { type: Boolean, required: false },
    afterSelectPersonalUrl: { type: Function, required: false, skipCheck: true },
    hideSlug: { type: Boolean, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: (_a = $setup.clerk) == null ? void 0 : _a.mountOrganizationList,
    unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountOrganizationList,
    "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var OrganizationList_default = export_helper_default(_sfc_main6, [["render", _sfc_render6], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/OrganizationList.vue"]]);
var _sfc_main7 = defineComponent({
  __name: "PricingTable",
  props: {
    forOrganizations: { type: Boolean, required: false },
    appearance: { type: Object, required: false },
    checkoutProps: { type: Object, required: false },
    ctaPosition: { type: String, required: false },
    collapseFeatures: { type: Boolean, required: false },
    newSubscriptionRedirectUrl: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const __returned__ = { clerk, props, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createBlock($setup["ClerkHostRenderer"], {
    mount: (_a = $setup.clerk) == null ? void 0 : _a.mountPricingTable,
    unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountPricingTable,
    "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps,
    props: $setup.props
  }, null, 8, ["mount", "unmount", "update-props", "props"]);
}
var PricingTable_default = export_helper_default(_sfc_main7, [["render", _sfc_render7], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/PricingTable.vue"]]);
var _sfc_main8 = defineComponent({
  __name: "OrganizationProfile",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    afterLeaveOrganizationUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    __experimental_startPath: { type: String, required: false },
    apiKeysProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const { customPages, customPagesPortals, addCustomPage } = useOrganizationProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      customPages: customPages.value
    }));
    provide(OrganizationProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { props, clerk, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: (_a = $setup.clerk) == null ? void 0 : _a.mountOrganizationProfile,
        unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountOrganizationProfile,
        props: $setup.finalProps,
        "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps
      }, null, 8, ["mount", "unmount", "props", "update-props"]),
      createVNode($setup["CustomPortalsRenderer"], { "custom-pages-portals": $setup.customPagesPortals }, null, 8, ["custom-pages-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var OrganizationProfile_default = export_helper_default(_sfc_main8, [["render", _sfc_render8], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/OrganizationProfile/OrganizationProfile.vue"]]);
var OrganizationProfilePage = defineComponent(
  (props, { slots }) => {
    const ctx = inject(OrganizationProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(organizationProfilePageRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: OrganizationProfilePage
    });
    return () => null;
  },
  { name: "OrganizationProfilePage" }
);
Object.defineProperty(OrganizationProfilePage, "props", {
  value: ["label", "url"]
});
var OrganizationProfileLink = defineComponent(
  (props, { slots }) => {
    const ctx = inject(OrganizationProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(organizationProfileLinkRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: OrganizationProfileLink
    });
    return () => null;
  },
  { name: "OrganizationProfileLink" }
);
Object.defineProperty(OrganizationProfileLink, "props", {
  value: ["url", "label"]
});
var OrganizationProfile = Object.assign(OrganizationProfile_default, {
  Page: OrganizationProfilePage,
  Link: OrganizationProfileLink
});
var isThatComponent = (v, component) => {
  return !!v && isRenderFunction(v) && v.name === component.name;
};
var isRenderFunction = (v) => {
  return "name" in v && "setup" in v;
};
function generateElementIdentifier() {
  return Math.random().toString(36).substring(2, 7);
}
var useCustomElementPortal = () => {
  const rawPortals = ref([]);
  const portals = computed(() => {
    return rawPortals.value.map((item) => {
      return h(Teleport, { to: item.el }, item.slot());
    });
  });
  const mount = (el, slot) => {
    const id = generateElementIdentifier();
    el.setAttribute("data-clerk-mount-id", id);
    rawPortals.value.push({
      id,
      el,
      slot
    });
  };
  const unmount = (el) => {
    const id = el == null ? void 0 : el.getAttribute("data-clerk-mount-id");
    if (id) {
      const index = rawPortals.value.findIndex((portal) => portal.id === id);
      if (index !== -1) {
        rawPortals.value.splice(index, 1);
      }
    }
  };
  return {
    portals,
    mount,
    unmount
  };
};
var useUserProfileCustomPages = () => {
  const { customPages, customPagesPortals, addCustomPage } = useCustomPages({
    reorderItemsLabels: ["account", "security"],
    PageComponent: UserProfilePage,
    LinkComponent: UserProfileLink,
    componentName: "UserProfile"
  });
  const addUserProfileCustomPage = (params) => {
    return addCustomPage(params);
  };
  return {
    customPages,
    customPagesPortals,
    addCustomPage: addUserProfileCustomPage
  };
};
var useOrganizationProfileCustomPages = () => {
  const { customPages, customPagesPortals, addCustomPage } = useCustomPages({
    reorderItemsLabels: ["general", "members"],
    PageComponent: OrganizationProfilePage,
    LinkComponent: OrganizationProfileLink,
    componentName: "OrganizationProfile"
  });
  const addOrganizationProfileCustomPage = (params) => {
    return addCustomPage(params);
  };
  return {
    customPages,
    customPagesPortals,
    addCustomPage: addOrganizationProfileCustomPage
  };
};
var useCustomPages = (customPagesParams) => {
  const customPages = ref([]);
  const { portals: customPagesPortals, mount, unmount } = useCustomElementPortal();
  const { PageComponent, LinkComponent, reorderItemsLabels, componentName } = customPagesParams;
  const addCustomPage = (params) => {
    const { props, slots, component } = params;
    const { label, url } = props;
    if (isThatComponent(component, PageComponent)) {
      if (isReorderItem(props, slots, reorderItemsLabels)) {
        customPages.value.push({ label });
      } else if (isCustomPage(props, slots)) {
        customPages.value.push({
          label,
          url,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount,
          mount(el) {
            mount(el, slots.default);
          },
          unmount
        });
      } else {
        logErrorInDevMode(customPageWrongProps(componentName));
        return;
      }
    }
    if (isThatComponent(component, LinkComponent)) {
      if (isExternalLink(props, slots)) {
        customPages.value.push({
          label,
          url,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount
        });
      } else {
        logErrorInDevMode(customLinkWrongProps(componentName));
        return;
      }
    }
  };
  return {
    customPages,
    customPagesPortals,
    addCustomPage
  };
};
var isReorderItem = (props, slots, validItems) => {
  const { label, url } = props;
  const { default: defaultSlot, labelIcon } = slots;
  return !defaultSlot && !url && !labelIcon && validItems.some((v) => v === label);
};
var isCustomPage = (props, slots) => {
  const { label, url } = props;
  const { default: defaultSlot, labelIcon } = slots;
  return !!defaultSlot && !!url && !!labelIcon && !!label;
};
var isExternalLink = (props, slots) => {
  const { label, url } = props;
  const { default: defaultSlot, labelIcon } = slots;
  return !defaultSlot && !!url && !!labelIcon && !!label;
};
var _sfc_main9 = defineComponent({
  __name: "UserProfile",
  props: {
    path: { type: null, required: false },
    routing: { type: String, required: false },
    appearance: { type: Object, required: false },
    additionalOAuthScopes: { type: Object, required: false },
    __experimental_startPath: { type: String, required: false },
    apiKeysProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const { customPages, customPagesPortals, addCustomPage } = useUserProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      customPages: customPages.value
    }));
    provide(UserProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { props, clerk, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: (_a = $setup.clerk) == null ? void 0 : _a.mountUserProfile,
        unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountUserProfile,
        props: $setup.finalProps,
        "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps
      }, null, 8, ["mount", "unmount", "props", "update-props"]),
      createVNode($setup["CustomPortalsRenderer"], { "custom-pages-portals": $setup.customPagesPortals }, null, 8, ["custom-pages-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var UserProfile_default = export_helper_default(_sfc_main9, [["render", _sfc_render9], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/UserProfile/UserProfile.vue"]]);
var UserProfilePage = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userProfilePageRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: UserProfilePage
    });
    return () => null;
  },
  { name: "UserProfilePage" }
);
Object.defineProperty(UserProfilePage, "props", {
  value: ["label", "url"]
});
var UserProfileLink = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserProfileInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userProfileLinkRenderedError);
    }
    ctx.addCustomPage({
      props,
      slots,
      component: UserProfileLink
    });
    return () => null;
  },
  { name: "UserProfileLink" }
);
Object.defineProperty(UserProfileLink, "props", {
  value: ["url", "label"]
});
var UserProfile = Object.assign(UserProfile_default, {
  Page: UserProfilePage,
  Link: UserProfileLink
});
var _sfc_main10 = defineComponent({
  __name: "OrganizationSwitcher",
  props: {
    createOrganizationUrl: { type: null, required: false },
    createOrganizationMode: { type: String, required: false },
    organizationProfileUrl: { type: null, required: false },
    organizationProfileMode: { type: String, required: false },
    defaultOpen: { type: Boolean, required: false },
    hidePersonal: { type: Boolean, required: false },
    afterSwitchOrganizationUrl: { type: String, required: false },
    afterCreateOrganizationUrl: { type: Function, required: false, skipCheck: true },
    afterSelectOrganizationUrl: { type: Function, required: false, skipCheck: true },
    afterSelectPersonalUrl: { type: Function, required: false, skipCheck: true },
    afterLeaveOrganizationUrl: { type: String, required: false },
    skipInvitationScreen: { type: Boolean, required: false },
    hideSlug: { type: Boolean, required: false },
    appearance: { type: Object, required: false },
    organizationProfileProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const clerk = useClerk();
    const props = __props;
    const { customPages, customPagesPortals, addCustomPage } = useOrganizationProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      organizationProfileProps: {
        ...props.organizationProfileProps || {},
        customPages: customPages.value
      }
    }));
    provide(OrganizationProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { clerk, props, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: (_a = $setup.clerk) == null ? void 0 : _a.mountOrganizationSwitcher,
        unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountOrganizationSwitcher,
        "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps,
        props: $setup.finalProps
      }, null, 8, ["mount", "unmount", "update-props", "props"]),
      createVNode($setup["CustomPortalsRenderer"], { "custom-pages-portals": $setup.customPagesPortals }, null, 8, ["custom-pages-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var OrganizationSwitcher_default = export_helper_default(_sfc_main10, [["render", _sfc_render10], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/OrganizationSwitcher/OrganizationSwitcher.vue"]]);
var OrganizationSwitcher = Object.assign(OrganizationSwitcher_default, {
  OrganizationProfilePage,
  OrganizationProfileLink
});
var useUserButtonCustomMenuItems = () => {
  const customMenuItems = ref([]);
  const { portals: customMenuItemsPortals, mount, unmount } = useCustomElementPortal();
  const reorderItemsLabels = ["manageAccount", "signOut"];
  function addCustomMenuItem(params) {
    const { props, component, slots } = params;
    const { label, onClick, open, href } = props;
    if (isThatComponent(component, MenuAction)) {
      if (isReorderItem2(props, slots, reorderItemsLabels)) {
        customMenuItems.value.push({ label });
      } else if (isCustomMenuItem(props, slots)) {
        const baseItem = {
          label,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount
        };
        if (onClick !== void 0) {
          customMenuItems.value.push({
            ...baseItem,
            onClick,
            open
          });
        } else if (open !== void 0) {
          customMenuItems.value.push({
            ...baseItem,
            open: open.startsWith("/") ? open : `/${open}`
          });
        } else {
          logErrorInDevMode("Custom menu item must have either onClick or open property");
          return;
        }
      } else {
        logErrorInDevMode(userButtonMenuItemActionWrongProps);
        return;
      }
    }
    if (isThatComponent(component, MenuLink)) {
      if (isExternalLink2(props, slots)) {
        customMenuItems.value.push({
          label,
          href,
          mountIcon(el) {
            mount(el, slots.labelIcon);
          },
          unmountIcon: unmount
        });
      } else {
        logErrorInDevMode(userButtonMenuItemLinkWrongProps);
        return;
      }
    }
  }
  return {
    customMenuItems,
    customMenuItemsPortals,
    addCustomMenuItem
  };
};
var isReorderItem2 = (props, slots, validItems) => {
  const { label, onClick } = props;
  const { labelIcon } = slots;
  return !onClick && !labelIcon && validItems.some((v) => v === label);
};
var isCustomMenuItem = (props, slots) => {
  const { label, onClick, open } = props;
  const { labelIcon } = slots;
  return !!labelIcon && !!label && (typeof onClick === "function" || typeof open === "string");
};
var isExternalLink2 = (props, slots) => {
  const { label, href } = props;
  const { labelIcon } = slots;
  return !!href && !!labelIcon && !!label;
};
var _sfc_main11 = defineComponent({
  __name: "UserButton",
  props: {
    userProfileUrl: { type: null, required: false },
    userProfileMode: { type: String, required: false },
    showName: { type: Boolean, required: false },
    defaultOpen: { type: Boolean, required: false },
    __experimental_asStandalone: { type: [Boolean, Function], required: false },
    afterSignOutUrl: { type: String, required: false },
    afterMultiSessionSingleSignOutUrl: { type: String, required: false },
    signInUrl: { type: String, required: false },
    afterSwitchSessionUrl: { type: String, required: false },
    appearance: { type: Object, required: false },
    userProfileProps: { type: Object, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const { customMenuItems, customMenuItemsPortals, addCustomMenuItem } = useUserButtonCustomMenuItems();
    const { customPages, customPagesPortals, addCustomPage } = useUserProfileCustomPages();
    const finalProps = computed(() => ({
      ...props,
      userProfileProps: {
        ...props.userProfileProps || {},
        customPages: customPages.value
      },
      customMenuItems: customMenuItems.value
    }));
    provide(UserButtonInjectionKey, {
      addCustomMenuItem
    });
    provide(UserProfileInjectionKey, {
      addCustomPage
    });
    const __returned__ = { props, clerk, customMenuItems, customMenuItemsPortals, addCustomMenuItem, customPages, customPagesPortals, addCustomPage, finalProps, get ClerkHostRenderer() {
      return ClerkHostRenderer;
    }, get CustomPortalsRenderer() {
      return CustomPortalsRenderer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c;
  return openBlock(), createElementBlock(
    Fragment,
    null,
    [
      createVNode($setup["ClerkHostRenderer"], {
        mount: (_a = $setup.clerk) == null ? void 0 : _a.mountUserButton,
        unmount: (_b = $setup.clerk) == null ? void 0 : _b.unmountUserButton,
        props: $setup.finalProps,
        "update-props": (_c = $setup.clerk) == null ? void 0 : _c.__unstable__updateProps
      }, null, 8, ["mount", "unmount", "props", "update-props"]),
      createVNode($setup["CustomPortalsRenderer"], {
        "custom-pages-portals": $setup.customPagesPortals,
        "custom-menu-items-portals": $setup.customMenuItemsPortals
      }, null, 8, ["custom-pages-portals", "custom-menu-items-portals"]),
      renderSlot(_ctx.$slots, "default")
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
var UserButton_default = export_helper_default(_sfc_main11, [["render", _sfc_render11], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/ui-components/UserButton/UserButton.vue"]]);
var MenuItems = defineComponent((_, { slots }) => {
  const ctx = inject(UserButtonInjectionKey);
  if (!ctx) {
    return errorThrower.throw(userButtonMenuItemsRenderedError);
  }
  provide(UserButtonMenuItemsInjectionKey, ctx);
  return () => {
    var _a;
    return (_a = slots.default) == null ? void 0 : _a.call(slots);
  };
});
var MenuAction = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserButtonMenuItemsInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userButtonMenuActionRenderedError);
    }
    ctx.addCustomMenuItem({
      props,
      slots,
      component: MenuAction
    });
    return () => null;
  },
  { name: "MenuAction" }
);
Object.defineProperty(MenuAction, "props", {
  value: ["label", "onClick", "open"]
});
var MenuLink = defineComponent(
  (props, { slots }) => {
    const ctx = inject(UserButtonMenuItemsInjectionKey);
    if (!ctx) {
      return errorThrower.throw(userButtonMenuLinkRenderedError);
    }
    ctx.addCustomMenuItem({
      props,
      slots,
      component: MenuLink
    });
    return () => null;
  },
  { name: "MenuLink" }
);
Object.defineProperty(MenuLink, "props", {
  value: ["href", "label"]
});
var UserButton = Object.assign(UserButton_default, {
  MenuItems,
  Action: MenuAction,
  Link: MenuLink,
  UserProfilePage,
  UserProfileLink
});
var _sfc_main12 = defineComponent({
  __name: "SignInButton",
  props: {
    mode: { type: String, required: false },
    appearance: { type: null, required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    signUpForceRedirectUrl: { type: [String, null], required: false },
    signUpFallbackRedirectUrl: { type: [String, null], required: false },
    initialValues: { type: Object, required: false },
    withSignUp: { type: Boolean, required: false },
    oauthFlow: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      var _a;
      const children = normalizeWithDefaultValue((_a = slots.default) == null ? void 0 : _a.call(slots, {}), "Sign in");
      return assertSingleChild(children, "SignInButton");
    }
    function clickHandler() {
      var _a, _b;
      const { mode, ...opts } = props;
      if (mode === "modal") {
        return (_a = clerk.value) == null ? void 0 : _a.openSignIn({ ...opts, appearance: props.appearance });
      }
      const { withSignUp, ...redirectOpts } = opts;
      void ((_b = clerk.value) == null ? void 0 : _b.redirectToSignIn({
        ...redirectOpts,
        signInFallbackRedirectUrl: props.fallbackRedirectUrl,
        signInForceRedirectUrl: props.forceRedirectUrl
      }));
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignInButton_default = export_helper_default(_sfc_main12, [["render", _sfc_render12], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignInButton.vue"]]);
var _sfc_main13 = defineComponent({
  __name: "SignUpButton",
  props: {
    unsafeMetadata: { type: null, required: false },
    mode: { type: String, required: false },
    appearance: { type: null, required: false },
    fallbackRedirectUrl: { type: [String, null], required: false },
    forceRedirectUrl: { type: [String, null], required: false },
    signInForceRedirectUrl: { type: [String, null], required: false },
    signInFallbackRedirectUrl: { type: [String, null], required: false },
    initialValues: { type: Object, required: false },
    oauthFlow: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      var _a;
      const children = normalizeWithDefaultValue((_a = slots.default) == null ? void 0 : _a.call(slots, {}), "Sign up");
      return assertSingleChild(children, "SignUpButton");
    }
    function clickHandler() {
      var _a, _b;
      const { mode, ...opts } = props;
      if (mode === "modal") {
        return (_a = clerk.value) == null ? void 0 : _a.openSignUp({ ...opts, appearance: props.appearance });
      }
      void ((_b = clerk.value) == null ? void 0 : _b.redirectToSignUp({
        ...opts,
        signUpFallbackRedirectUrl: props.fallbackRedirectUrl,
        signUpForceRedirectUrl: props.forceRedirectUrl
      }));
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignUpButton_default = export_helper_default(_sfc_main13, [["render", _sfc_render13], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignUpButton.vue"]]);
var _sfc_main14 = defineComponent({
  __name: "SignOutButton",
  props: {
    signOutOptions: { type: Object, required: false },
    sessionId: { type: String, required: false },
    redirectUrl: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      var _a;
      const children = normalizeWithDefaultValue((_a = slots.default) == null ? void 0 : _a.call(slots, {}), "Sign out");
      return assertSingleChild(children, "SignOutButton");
    }
    function clickHandler() {
      var _a, _b, _c;
      const signOutOptions = {
        redirectUrl: ((_a = props.signOutOptions) == null ? void 0 : _a.redirectUrl) ?? props.redirectUrl,
        sessionId: ((_b = props.signOutOptions) == null ? void 0 : _b.sessionId) ?? props.sessionId
      };
      void ((_c = clerk.value) == null ? void 0 : _c.signOut(signOutOptions));
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignOutButton_default = export_helper_default(_sfc_main14, [["render", _sfc_render14], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignOutButton.vue"]]);
var _sfc_main15 = defineComponent({
  __name: "SignInWithMetamaskButton",
  props: {
    redirectUrl: { type: [String, null], required: false },
    mode: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props = __props;
    const clerk = useClerk();
    const slots = useSlots();
    const attrs = useAttrs();
    function getChildComponent() {
      var _a;
      const children = normalizeWithDefaultValue((_a = slots.default) == null ? void 0 : _a.call(slots, {}), "Sign in with Metamask");
      return assertSingleChild(children, "SignInWithMetamaskButton");
    }
    function clickHandler() {
      var _a;
      void ((_a = clerk.value) == null ? void 0 : _a.authenticateWithMetamask({ redirectUrl: props.redirectUrl || void 0 }));
    }
    const __returned__ = { props, clerk, slots, attrs, getChildComponent, clickHandler };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent($setup.getChildComponent),
    mergeProps($setup.attrs, { onClick: $setup.clickHandler }),
    {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
      /* FORWARDED */
    },
    16
    /* FULL_PROPS */
  );
}
var SignInWithMetamaskButton_default = export_helper_default(_sfc_main15, [["render", _sfc_render15], ["__file", "/home/runner/work/javascript/javascript/packages/vue/src/components/SignInWithMetamaskButton.vue"]]);
var SDK_METADATA = {
  name: "@clerk/vue",
  version: "1.8.14",
  environment: "development"
};
var clerkPlugin = {
  install(app, pluginOptions) {
    var _a, _b;
    const { initialState } = pluginOptions;
    const loaded = shallowRef(false);
    const clerk = shallowRef(null);
    const resources = ref({
      client: void 0,
      session: void 0,
      user: void 0,
      organization: void 0
    });
    const options = {
      ...pluginOptions,
      sdkMetadata: pluginOptions.sdkMetadata || SDK_METADATA
    };
    if (inBrowser()) {
      void loadClerkJsScript(options).then(async () => {
        if (!window.Clerk) {
          throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");
        }
        clerk.value = window.Clerk;
        await window.Clerk.load(options);
        loaded.value = true;
        clerk.value.addListener((payload) => {
          resources.value = payload;
        });
        triggerRef(clerk);
      });
    }
    const derivedState = computed(() => deriveState(loaded.value, resources.value, initialState));
    const authCtx = computed(() => {
      const {
        sessionId,
        userId,
        orgId,
        actor,
        orgRole,
        orgSlug,
        orgPermissions,
        sessionStatus,
        sessionClaims,
        factorVerificationAge
      } = derivedState.value;
      return {
        sessionId,
        userId,
        actor,
        orgId,
        orgRole,
        orgSlug,
        orgPermissions,
        sessionStatus,
        sessionClaims,
        factorVerificationAge
      };
    });
    const clientCtx = computed(() => resources.value.client);
    const userCtx = computed(() => derivedState.value.user);
    const sessionCtx = computed(() => derivedState.value.session);
    const organizationCtx = computed(() => derivedState.value.organization);
    app.provide(ClerkInjectionKey, {
      clerk,
      authCtx,
      clientCtx,
      sessionCtx,
      userCtx,
      organizationCtx,
      treatPendingAsSignedOut: options.treatPendingAsSignedOut ?? ((_b = (_a = clerk.value) == null ? void 0 : _a.__internal_getOption) == null ? void 0 : _b.call(_a, "treatPendingAsSignedOut"))
    });
  }
};
setErrorThrowerOptions({ packageName: "@clerk/vue" });
setClerkJsLoadingErrorPackageName("@clerk/vue");
export {
  AuthenticateWithRedirectCallback,
  ClerkLoaded,
  ClerkLoading,
  CreateOrganization_default as CreateOrganization,
  GoogleOneTap_default as GoogleOneTap,
  OrganizationList_default as OrganizationList,
  OrganizationProfile,
  OrganizationSwitcher,
  PricingTable_default as PricingTable,
  Protect,
  RedirectToCreateOrganization,
  RedirectToOrganizationProfile,
  RedirectToSignIn,
  RedirectToSignUp,
  RedirectToUserProfile,
  SignIn_default as SignIn,
  SignInButton_default as SignInButton,
  SignInWithMetamaskButton_default as SignInWithMetamaskButton,
  SignOutButton_default as SignOutButton,
  SignUp_default as SignUp,
  SignUpButton_default as SignUpButton,
  SignedIn,
  SignedOut,
  UserButton,
  UserProfile,
  Waitlist_default as Waitlist,
  clerkPlugin,
  updateClerkOptions,
  useAuth,
  useClerk,
  useOrganization,
  useSession,
  useSessionList,
  useSignIn,
  useSignUp,
  useUser
};
//# sourceMappingURL=@clerk_vue.js.map
